import { ApplicationCommandOptionType, ChannelType } from 'discord.js'
import { checkType } from '../utils/channels.js'
import {
  checkIfRoomOrTextChannel,
  createVoiceChannel,
  getChannelBasename,
  getChannelNumber,
  queueDelayedVoiceDelete,
} from '../utils/voice.js'
import { getDynamicVoiceRecordById } from '../repositories/voice.js'
import { queueApiCall } from '../api-queue.js'

export const description = `Opens a voice channel in relation to the current text channel.`
export const dmPermission = false,
  defaultMemberPermissions = `0`,
  options = [
    {
      name: `name`,
      description: `The name of the voice channel you're creating (defaults to the name of the channel you're in).`,
      type: ApplicationCommandOptionType.String,
      required: false,
    },
    {
      name: `dynamic`,
      description: `Choose if the voice channel dynamically expands so there's always an open channel (default true).`,
      type: ApplicationCommandOptionType.Boolean,
      required: false,
    },
    {
      name: `always-active`,
      description: `Choose if the voice channel always persists in the active voice category (default is false).`,
      type: ApplicationCommandOptionType.Boolean,
      required: false,
    },
    {
      name: `private`,
      description: `Contributors only; choose if the channel is private, /invite others (default is false).`,
      type: ApplicationCommandOptionType.Boolean,
      required: false,
    },
  ]

export default async function (interaction) {
  await queueApiCall({
    apiCall: `deferReply`,
    djsObject: interaction,
    parameters: { ephemeral: true },
  })

  const { guild, channel, options } = interaction,
    { name: channelName, id: channelId } = channel

  let name = options.getString(`name`),
    basename = getChannelBasename(name),
    dynamic = options.getBoolean(`dynamic`),
    alwaysActive = options.getBoolean(`always-active`),
    isPrivate = options.getBoolean(`private`)

  if (!name) {
    const dynamicVoiceRecord = await getDynamicVoiceRecordById(channelId)

    if (dynamicVoiceRecord) {
      await queueApiCall({
        apiCall: `deferReply`,
        djsObject: interaction,
        parameters: {
          content:
            "You can't create a voice channel based on another voice channel generated with `/voice` ü§î",
          ephemeral: true,
        },
      })
    }
  }

  return

  name = name ? name : channelName
  basename = basename ? basename : name
  dynamic = dynamic ? dynamic : true
  alwaysActive = alwaysActive ? alwaysActive : false
  isPrivate = isPrivate ? isPrivate : false

  const channelType = checkType(channel),
    isEphemeral = channelType === `public thread` ? false : true

  await interaction.deferReply({ ephemeral: isEphemeral })

  if ([`archived`, `hidden`, `voice`, `private thread`].includes(channelType)) {
    await interaction.editReply({
      content: `Sorry, this command cannot be used in private threads and some other channel types üòî`,
    })

    return
  }

  let voiceChannelName

  switch (channel.name) {
    case `rooms`:
      voiceChannelName = `room-1`
      break
    case `unverified-rooms`:
      voiceChannelName = `unverified-room-1`
      break
    default:
      if (channelType === `public thread`) voiceChannelName = `${channel.name}`
      else voiceChannelName = `${channel.name}-1`
  }

  const voiceChannel = await createVoiceChannel(channel, voiceChannelName)

  if (!voiceChannel) {
    let voiceChannel = guild.channels.cache.find(
      channel =>
        channel.name === voiceChannelName &&
        channel.type === ChannelType.GuildVoice
    )

    await interaction.editReply({
      content: `The **${voiceChannel}** voice channel already exists ü§î`,
    })

    return
  }

  const voiceChannelType = await checkIfRoomOrTextChannel(voiceChannel, guild)

  await interaction.editReply({
    content:
      `The **${voiceChannel}** voice channel has been created, have fun üòÅ` +
      `\n\n*Note that if no one joins a voice channel generated by this command within 30 seconds of creation it will be automatically deleted.*`,
  })

  queueDelayedVoiceDelete(voiceChannel, voiceChannelType)
}
